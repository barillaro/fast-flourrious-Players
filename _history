{"entries":[{"timestamp":1749628811850,"editorVersion":"7.0.61","changes":[{"type":"edited","filename":"backend.ts","patch":[{"diffs":[[0,"myID + \""],[1," "],[0,"S:\" + my"]],"start1":908,"start2":908,"length1":16,"length2":17}]},{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"re)\n"],[-1,"radio.setGroup(defaultRadioGroup)\n"],[0,"// s"]],"start1":1682,"start2":1682,"length1":42,"length2":8},{"diffs":[[0,"tion"],[-1,"\nstartGame()"],[0,"\n\n//"]],"start1":1737,"start2":1737,"length1":20,"length2":8}]}]},{"timestamp":1749628941004,"editorVersion":"7.0.61","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"ver\"\n   if ("],[-1,"fals"],[1,"tru"],[0,"e) {\n       "]],"start1":2925,"start2":2925,"length1":28,"length2":27}]}]},{"timestamp":1749629746125,"editorVersion":"7.0.61","changes":[{"type":"edited","filename":"backend.ts","patch":[{"diffs":[[0,"myID + \""],[-1," "],[0,"S:\" + my"]],"start1":908,"start2":908,"length1":17,"length2":16}]}]},{"timestamp":1749629764453,"editorVersion":"7.0.61","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"ssage = "],[-1,"tru"],[1,"fals"],[0,"e;\n// Se"]],"start1":1146,"start2":1146,"length1":19,"length2":20}]}]},{"timestamp":1749630560958,"editorVersion":"7.0.61","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"ring) {\n"],[-1,"    \n"],[0,"// ====="]],"start1":2012,"start2":2012,"length1":21,"length2":16}]}]},{"timestamp":1749630572258,"editorVersion":"7.0.61","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"    "],[-1,"music.createSoundExpression(WaveShape.Sine, 5000, 0, 255, 0, 500, SoundExpressionEffect.None, InterpolationCurve.Linear)"],[0,"\n// "]],"start1":2020,"start2":2020,"length1":128,"length2":8}]}]},{"timestamp":1749630573219,"editorVersion":"7.0.61","changes":[{"type":"edited","filename":"backend.ts","patch":[{"diffs":[[0,"Helper: "],[-1,"De"],[1,"Bomb Exploded"],[0," ===\nfun"]],"start1":2395,"start2":2395,"length1":18,"length2":29}]}]},{"timestamp":1749635104382,"editorVersion":"7.0.61","changes":[{"type":"edited","filename":"backend.ts","patch":[{"diffs":[[0,": De"],[-1,"livery Fail"],[0," ==="]],"start1":2401,"start2":2401,"length1":19,"length2":8}]}]},{"timestamp":1749635107146,"editorVersion":"7.0.61","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,", \"2\"]\n\n"],[-1,"\n"],[0,"// ====="]],"start1":1492,"start2":1492,"length1":17,"length2":16},{"diffs":[[0,"sic."],[-1,"playTone(262, 1"],[1,"createSoundExpression(WaveShape.Sine, 5000, 0, 255, 0, 5"],[0,"00"],[1,", SoundExpressionEffect.None, InterpolationCurve.Linear"],[0,")"],[-1,"\n"],[0,"\n// "]],"start1":2026,"start2":2026,"length1":27,"length2":122}]}]},{"timestamp":1749635236487,"editorVersion":"7.0.61","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"= Task: "],[1,"2 (a)"],[0,"\n// ===="]],"start1":2105,"start2":2105,"length1":16,"length2":21}]}]},{"timestamp":1749636553023,"editorVersion":"7.0.61","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,", 100)\n\n"],[1,"// =======================================\n// ========= Task: \n// =======================================\n// TODO: Set printMessage to false to stop showing the message on the LED display\n"],[0,"    // Y"]],"start1":2043,"start2":2043,"length1":16,"length2":204}]}]},{"timestamp":1749636595899,"editorVersion":"7.0.61","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"===\n"],[-1,"// =======================================\n// ========= Task: \n// =======================================\n// TODO: Set printMessage to false to stop showing the message on the LED display\n"],[0,"// p"]],"start1":1108,"start2":1108,"length1":196,"length2":8},{"diffs":[[0,"= true;\n"],[-1,"\n"],[0,"// Set t"]],"start1":1152,"start2":1152,"length1":17,"length2":16},{"diffs":[[0," Task: 2"],[1," (b)"],[0,"\n"],[-1,""],[0,"// ====="]],"start1":2649,"start2":2649,"length1":17,"length2":21},{"diffs":[[0,"ual to \"game"],[-1,"O"],[1,"o"],[0,"ver\"\n   if ("]],"start1":2749,"start2":2749,"length1":25,"length2":25},{"diffs":[[0,"he game\n"],[1,""],[0,"        "]],"start1":2833,"start2":2833,"length1":16,"length2":16},{"diffs":[[0,"e()\n"],[-1,"        // return makes the function end\n"],[0,"    "]],"start1":2855,"start2":2855,"length1":49,"length2":8}]}]},{"timestamp":1749636731726,"editorVersion":"7.0.61","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0," extract"],[-1,"s"],[0," the fir"]],"start1":3272,"start2":3272,"length1":17,"length2":16}]}]},{"timestamp":1749640602918,"editorVersion":"7.0.61","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"    if ("],[-1,"header"],[1,"false"],[0,") {\n    "]],"start1":3464,"start2":3464,"length1":22,"length2":21}]}]},{"timestamp":1749641094867,"editorVersion":"7.0.61","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"if ("],[-1,"message == \"gameOver\""],[1,"false"],[0,") {\n"]],"start1":2955,"start2":2955,"length1":29,"length2":13},{"diffs":[[0,"ader"],[-1," == \"order\""],[0,") {\n"]],"start1":3474,"start2":3474,"length1":19,"length2":8}]}]},{"timestamp":1749641312692,"editorVersion":"7.0.61","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0," order! "],[-1,"\n        "],[0,"Process "]],"start1":3542,"start2":3542,"length1":25,"length2":16}]}]},{"timestamp":1749669134359,"editorVersion":"7.0.61","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"order! \n"],[1,"        "],[0,"Process "]],"start1":3543,"start2":3543,"length1":16,"length2":24}]}]},{"timestamp":1749669141309,"editorVersion":"7.0.61","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"er! "],[-1,"Decode the message to obtain the information\n        let messageInfo = decode(message);\n        //"],[1,"\n"],[0,"Proc"]],"start1":3546,"start2":3546,"length1":106,"length2":9},{"diffs":[[0," message"],[-1," information"],[0,"!\n      "]],"start1":3568,"start2":3568,"length1":28,"length2":16},{"diffs":[[0,"\n}\n\n"],[-1,"function decode(message:string){\n    // The message received has four parts: order, Courier ID, ring bell, and delivery time.\n    // All the parts are together, separated by a :\n    // For example order:5:B:6\n    // We need to split the parts by the separator\n    let mParts = message.split(\":\")\n    // We store the fields in variables starting with m (m for message)\n    let mType = \"\";\n    let mCourierId = 0;\n    let mDelyDoor = \"\";\n    let mDelyTime = 0;\n    // =======================================\n    // ========= Task: 4\n    // =======================================\n    //TODO: take the message parts (0, 1, 2, and 3) \n    //      in separated variables (mType, mCourierId, mDelyDoor, mDelyTime)\n    mType = mParts[0];\n    \n    // Return a structure with all the message information\n    return {\n        type: mType,\n        courierId: mCourierId,\n        delyDoor: mDelyDoor,\n        delyTime: mDelyTime\n    };\n\n}\n\n"],[0,"func"]],"start1":3645,"start2":3645,"length1":936,"length2":8}]}]},{"timestamp":1749669598617,"editorVersion":"7.0.61","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"(message"],[-1,"Info"],[0,")\n    }\n"]],"start1":3739,"start2":3739,"length1":20,"length2":16},{"diffs":[[0,"\n    };\n"],[1,"\n"],[0,"}\n\nfunct"]],"start1":4674,"start2":4674,"length1":16,"length2":17}]}]},{"timestamp":1749669775236,"editorVersion":"7.0.61","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"(message"],[-1,"Info"],[1,": string"],[0,") {\n    "]],"start1":4717,"start2":4717,"length1":20,"length2":24}]}]},{"timestamp":1749672711360,"editorVersion":"7.0.61","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"   if (m"],[-1,"essage"],[0,"CourierI"]],"start1":5457,"start2":5457,"length1":22,"length2":16}]}]},{"timestamp":1749672738040,"editorVersion":"7.0.61","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"der!"],[-1,"\n        // Just a visual representation\n        announceOrder();\n        //"],[0," Dec"]],"start1":3545,"start2":3545,"length1":84,"length2":8},{"diffs":[[0,"mation!\n"],[1,"        announceOrder();\n"],[0,"        "]],"start1":3679,"start2":3679,"length1":16,"length2":41},{"diffs":[[0,"Info"],[-1,":any"],[0,") {\n"]],"start1":4725,"start2":4725,"length1":12,"length2":8},{"diffs":[[0,"  //"],[1," The"],[0," message"],[-1,"Info has all the information of the message\n    // Use the information to decide what to do next"],[1," received has four parts: order, Courier ID, ring bell, and delivery time.\n    // All the parts are together, separated by a :\n    // For example order:5:B:6\n    // We need to split the parts by the separator\n    let mParts = message.split(\":\")\n    // We store the fields in variables starting with m (m for message)\n    let mType = \"\";\n    let mCourierId = 0;\n    let mDelyDoor = \"\";\n    let mDelyTime = 0;\n// =======================================\n// ========= Task: 4\n// =======================================\n//TODO: take the message parts (0, 1, 2, and 3) \n//      in separated variables (mType, mCourierId, mDelyDoor, mDelyTime)\n    mType = mParts[0];"],[0,"\n\n    //"],[-1," "],[0,"Chec"]],"start1":4735,"start2":4735,"length1":121,"length2":687},{"diffs":[[0,"\n    if (message"],[-1,"Info."],[0,"CourierId == myI"]],"start1":5455,"start2":5455,"length1":37,"length2":32},{"diffs":[[0,"age "],[-1,"info into the micro:bit memory"],[1,"data:"],[0,"\n   "]],"start1":5626,"start2":5626,"length1":38,"length2":13},{"diffs":[[0,"delyDoor = m"],[-1,"essageInfo."],[0,"DelyDoor\n   "]],"start1":5644,"start2":5644,"length1":35,"length2":24},{"diffs":[[0,"Time = m"],[-1,"essageInfo."],[0,"DelyTime"]],"start1":5677,"start2":5677,"length1":27,"length2":16},{"diffs":[[0,"f (m"],[-1,"essageInfo."],[0,"Cour"]],"start1":6223,"start2":6223,"length1":19,"length2":8},{"diffs":[[0,"== myID)"],[1," "],[0,"\n       "]],"start1":6237,"start2":6237,"length1":16,"length2":17}]}]},{"timestamp":1749673231147,"editorVersion":"7.0.61","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"];\n    \n"],[-1,"    \n"],[0,"    // R"]],"start1":4541,"start2":4541,"length1":21,"length2":16}]}]},{"timestamp":1749676749562,"editorVersion":"7.0.61","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"0];\n    "],[-1,"m"],[0,"\n    \n  "]],"start1":4540,"start2":4540,"length1":17,"length2":16}]}]},{"timestamp":1749676750453,"editorVersion":"7.0.61","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"r:5:B:6\n"],[1,"    // We need to split the parts by the separator\n    let mParts = message.split(\":\")\n"],[0,"    // W"]],"start1":4014,"start2":4014,"length1":16,"length2":103},{"diffs":[[0," 0;\n"],[-1,"    let mParts = [];\n"],[0,"    "]],"start1":4268,"start2":4268,"length1":29,"length2":8},{"diffs":[[0,"ODO:"],[-1," split the message by the separator :\n    //     "],[0," tak"]],"start1":4398,"start2":4398,"length1":57,"length2":8},{"diffs":[[0," 3) "],[-1,"in separated \n    //     "],[1,"\n    //      in separated"],[0," var"]],"start1":4439,"start2":4439,"length1":33,"length2":33},{"diffs":[[0,"    "],[-1,"// We need to split the parts by the separator\n    mParts = message.split(\":\")\n    mType = mParts[0];\n    mCourierId = parseInt(mParts[1]);\n    // mDelyDoor = mParts[2];\n    // mDelyTime = parseInt(mParts[3]);\n"],[1,"mType = mParts[0];\n    m\n    "],[0,"\n   "]],"start1":4521,"start2":4521,"length1":218,"length2":37},{"diffs":[[0,", not A\n})\n\n"],[1,"// =======================================\n// ========= Task: 5\n// =======================================\n// TODO: add an input function to process the input Button B\n"],[0,"input.onButt"]],"start1":6140,"start2":6140,"length1":24,"length2":192},{"diffs":[[0,"    "],[-1,"deliverTo(\"B\"); // Use \"B\", not B"],[1,"// HINT: it is almost identical to the Button A input function"],[0,"\n})\n"]],"start1":6404,"start2":6404,"length1":41,"length2":70},{"diffs":[[0,"verTo(\"0\");\n})\n\n"],[1,"// TODO: add an input function to process the Pin 1\n"],[0,"input.onPinPress"]],"start1":6618,"start2":6618,"length1":32,"length2":84},{"diffs":[[0,"    "],[-1,"deliverTo(\"1\");\n})\n"],[1,"// HINT: it is almost identical to the P0 input function\n})\n\n// TODO: add an input function to process the Pin 2"],[0,"\ninp"]],"start1":6769,"start2":6769,"length1":27,"length2":120},{"diffs":[[0,"    "],[-1,"deliverTo(\"2\");"],[1,"// HINT: it is almost identical to the P0 input function"],[0,"\n})\n"]],"start1":6969,"start2":6969,"length1":23,"length2":64}]}]},{"timestamp":1749677354899,"editorVersion":"7.0.61","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,", not B\n})\n\n"],[1,"// TODO: add an input function to process the Pin 0\n"],[0,"input.onPinP"]],"start1":6430,"start2":6430,"length1":24,"length2":76}]}]},{"timestamp":1749677356775,"editorVersion":"7.0.61","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"})\n\n"],[-1,"// This function executes when the button B is pressed\n"],[0,"inpu"]],"start1":6312,"start2":6312,"length1":63,"length2":8},{"diffs":[[0,"})\n\n"],[-1,"// This function executes when the pin 0 is closed\n"],[0,"inpu"]],"start1":6438,"start2":6438,"length1":59,"length2":8},{"diffs":[[0,"})\n\n"],[-1,"// This function executes when the pin 1 is closed\n"],[0,"inpu"]],"start1":6545,"start2":6545,"length1":59,"length2":8},{"diffs":[[0,"})\n\n"],[-1,"// This function executes when the pin 2 is closed\n"],[0,"inpu"]],"start1":6652,"start2":6652,"length1":59,"length2":8},{"diffs":[[0,"ve == true) "],[-1,"{"],[0,"\n    "],[-1," "],[1,"{"],[0,"   // The or"]],"start1":7229,"start2":7229,"length1":31,"length2":30},{"diffs":[[0,"ell\n"],[-1,"        if (delyDoor == ringPressed){\n    "],[1,"// =======================================\n// ========= Task: 6\n// =======================================\n// TODO: Check if you pressed the right ringbell\n    if (false){\n"],[0,"    "]],"start1":7337,"start2":7337,"length1":50,"length2":180}]}]},{"timestamp":1749677771772,"editorVersion":"7.0.61","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"ion "],[-1,"encodeInfo"],[1,"prepareOrder"],[0,"():s"]],"start1":8533,"start2":8533,"length1":18,"length2":20},{"diffs":[[0,"= Task: "],[-1,"6"],[1,"8"],[0,"\n// ===="]],"start1":10193,"start2":10193,"length1":17,"length2":17},{"diffs":[[0,"ion send"],[-1,"Message"],[1,"Order"],[0,"(message"]],"start1":10521,"start2":10521,"length1":23,"length2":21},{"diffs":[[0,"========= Task: "],[-1,"7"],[1,"9"],[0,"\n// ============"]],"start1":10633,"start2":10633,"length1":33,"length2":33}]}]},{"timestamp":1749678284001,"editorVersion":"7.0.61","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"sk: "],[-1,"8"],[1,"7"],[0,"\n// "]],"start1":8287,"start2":8287,"length1":9,"length2":9},{"diffs":[[0,"===============\n"],[-1,"    "],[0,"// TODO: \n    us"]],"start1":8320,"start2":8320,"length1":36,"length2":32},{"diffs":[[0,"DO: "],[-1,"\n    use the message to broadcast by radio\n        let message = \"\"\n        message = encodeInfo();\n        sendMessage(message);"],[1,"Create an order, prepare the order, and send the order.\n"],[0,"\n   "]],"start1":8341,"start2":8341,"length1":137,"length2":64},{"diffs":[[0,"ts ;-)\n\n"],[-1,"    "],[0,"// retur"]],"start1":10409,"start2":10409,"length1":20,"length2":16},{"diffs":[[0," return the "],[-1,"message"],[1,"order"],[0,"\n    // The "]],"start1":10419,"start2":10419,"length1":31,"length2":29},{"diffs":[[0,"String(\""],[1,"your order here"],[0,"\")\n}\n\n"]],"start1":10759,"start2":10759,"length1":14,"length2":29}]}]},{"timestamp":1749678882337,"editorVersion":"7.0.61","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"    "],[-1,"    let message = \"\"\n        // TODO: use encodeInfo funtion to create a"],[1,"// TODO: \n    use the message to broadcast by radio\n        let"],[0," message"],[1," = \"\""],[0,"\n       "],[-1," //"],[0," mes"]],"start1":8336,"start2":8336,"length1":99,"length2":92},{"diffs":[[0,"    "],[-1," // TODO: use sendMessage function to send the message\n        //"],[0," sen"]],"start1":8452,"start2":8452,"length1":73,"length2":8}]}]},{"timestamp":1749679480482,"editorVersion":"7.0.61","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"sk: "],[-1,"7"],[1,"8"],[0,"\n// "]],"start1":8287,"start2":8287,"length1":9,"length2":9},{"diffs":[[0,"= Task: "],[-1,"5"],[1,"6"],[0,"\n// ===="]],"start1":10340,"start2":10340,"length1":17,"length2":17},{"diffs":[[0,"========= Task: "],[-1,"6"],[1,"7"],[0,"\n// ============"]],"start1":10788,"start2":10788,"length1":33,"length2":33}]}]},{"timestamp":1749679592516,"editorVersion":"7.0.61","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"\n// "],[-1,"Encode"],[1,"Assembly"],[0," all"]],"start1":10239,"start2":10239,"length1":14,"length2":16}]}]},{"timestamp":1749682259378,"editorVersion":"7.0.61","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"ts in a "],[1,"single"],[0," message"]],"start1":10261,"start2":10261,"length1":16,"length2":22}]}]},{"timestamp":1749682265742,"editorVersion":"7.0.61","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"   let mType"],[1,"Message"],[0," = \"order\"\n "]],"start1":9143,"start2":9143,"length1":24,"length2":31},{"diffs":[[0,"ode "],[-1,"the information to create a"],[1,"all the parts in a "],[0," mes"]],"start1":10246,"start2":10246,"length1":35,"length2":27},{"diffs":[[0,"rts "],[-1,"of information into a"],[1,"into a single"],[0," mes"]],"start1":10416,"start2":10416,"length1":29,"length2":21}]}]},{"timestamp":1749682766649,"editorVersion":"7.0.61","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"the "],[-1,"radio.sendString function to send the message"],[1,"message to broadcast"],[0," by "]],"start1":10867,"start2":10867,"length1":53,"length2":28}]}]},{"timestamp":1749683334779,"editorVersion":"7.0.61","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"p here)\n"],[1,"radio.setGroup(defaultRadioGroup)\n"],[0,"// start"]],"start1":1867,"start2":1867,"length1":16,"length2":50}]}]},{"timestamp":1749713238737,"editorVersion":"7.0.61","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"function"],[1,"\nstartGame()"],[0,"\n\n// ==="]],"start1":1922,"start2":1922,"length1":16,"length2":28}]}]},{"timestamp":1749713241623,"editorVersion":"7.0.61","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"    if ("],[-1,"false"],[1,"header == \"order\""],[0,") {\n    "]],"start1":3434,"start2":3434,"length1":21,"length2":33}]}]},{"timestamp":1749717393471,"editorVersion":"7.0.61","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0," radio!\n"],[-1,"    \n"],[0,"// ====="]],"start1":10677,"start2":10677,"length1":21,"length2":16}]}]},{"timestamp":1749717479152,"editorVersion":"7.0.61","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"ver\"\n   if ("],[-1,"false"],[1,"message == \"gameOver\""],[0,") {\n        "]],"start1":2901,"start2":2901,"length1":29,"length2":45},{"diffs":[[0,"    "],[-1,"music.play(music.builtinPlayableSoundEffect(soundExpression.hello), music.PlaybackMode.UntilDone)"],[0,"\n// "]],"start1":10685,"start2":10685,"length1":105,"length2":8}]}]},{"timestamp":1749803267288,"editorVersion":"7.0.61","changes":[{"type":"added","filename":"main.blocks","value":"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <block type=\"pxt-on-start\"></block>\n  <block type=\"device_forever\"></block>\n</xml>"}]}],"snapshots":[{"timestamp":1749628811849,"editorVersion":"7.0.61","text":{"main.ts":"/****************************************************************************************\n * Project: Micro:bit Multiplayer Game\n * Description: Core logic and custom extensions for micro:bit multiplayer interaction.\n * \n * File: main.ts\n * Contains: Main logic. Task 1\n * \n * Author: Sebastian Barillaro\n * Date: 2025-06-10\n * Platform: Microsoft MakeCode for micro:bit\n * \n * Notes:\n * - Designed for use with MakeCode editor (https://makecode.microbit.org/)\n * - Compatible with MakeCode's TypeScript (pxt) environment\n * \n * License: Reserved for Luxembourg Tech School ASBL\n ****************************************************************************************/\n\n\n// === Constants ===\nconst defaultDelyTime = 6  // seconds\nconst defaultRadioGroup = 10\nconst mGameOver = \"gameOver\"\n\n// === Flag Variables ===\nlet orderActive = false // false = order not active ; true = order activated!\nlet gameOver = false // false = game is NOT over (playing) ; true = the game is over.\n\n// === Support Variables ===\nlet delyDoor = \"\"\nlet delyTime = defaultDelyTime;\nlet myScore = 0\n\n// === Configuration variables ===\n// print radio Message\nlet printMessage = false;\n// Set the number of players!\nlet players = 20;\n// Set your ID (Must be unique in your group)\nlet myID = randint(1, players); // Change the random value for something fix\n// Set the difficulty of the game: \"easy\", (more to come later)\nlet difficulty = \"easy\";\n// Set the ringbell options list\nlet ringbellPanel = [\"A\", \"B\", \"0\", \"1\", \"2\"]\n\n// =======================================\n// ========= Task 1:\n// =======================================\n// Configure the radio Group\n// TODO: radio.setGroup(use the radioGroup here)\n// start the game!\n// TODO: Call the startGame function\n\n// === Receive Radio Message ===\n// This function executes when the device receives a radio message.\nradio.onReceivedString(radioMessageReceived)\n\n// === handler of the reception ===\nfunction radioMessageReceived(message: string) {\n// =======================================\n// ========= Task: 2 (a)\n// =======================================\n// TODO: Set printMessage to false to stop showing the message on the LED display\n    // You have received a radio message. We will print it on the display\n    if (printMessage == true){\n        basic.showString(message);\n    }\n\n    // If the game is over, we do nothing (return)\n    if (gameOver == true) {\n        // Show the NO icon during 1 second (a visual reference)\n        basic.showIcon(IconNames.Ghost)\n        basic.pause(1000)\n        return // This return instruction ends the function. \n               // It continues where it was called from\n    }\n\n    // The game is not over. Let's see what we have received\n// =======================================\n// ========= Task: 2 (b)\n// =======================================\n// TODO: check if the message received is equal to \"gameover\"\n   if (true) {\n        // The message received indicates to end the game\n        endGame()\n        return;\n    }\n\n    // The header of the message indicates what type of message is\n    // Let's extract the header of the message\n    let header = message.substr(0, 5) // this line extract the first 5 letters\n// =======================================\n// ========= Task: 3\n// =======================================\n// TODO: Check if the header of the message is \"order\"\n    if (false) {\n        // The message is of type order! Process the order message!\n        announceOrder();\n        processOrderMessage(message)\n    }\n}\n\nfunction processOrderMessage(message: string) {\n    // The message received has four parts: order, Courier ID, ring bell, and delivery time.\n    // All the parts are together, separated by a :\n    // For example order:5:B:6\n    // We need to split the parts by the separator\n    let mParts = message.split(\":\")\n    // We store the fields in variables starting with m (m for message)\n    let mType = \"\";\n    let mCourierId = 0;\n    let mDelyDoor = \"\";\n    let mDelyTime = 0;\n// =======================================\n// ========= Task: 4\n// =======================================\n//TODO: take the message parts (0, 1, 2, and 3) \n//      in separated variables (mType, mCourierId, mDelyDoor, mDelyTime)\n    mType = mParts[0];\n\n    //Check if the order was sent to me :-O\n    if (mCourierId == myID) {\n        // Caramba!! The order is for me!!!\n        // mark the flag order active!\n        orderActive = true\n        // save the message data:\n        delyDoor = mDelyDoor\n        delyTime = mDelyTime\n\n        // Show the door to deliver the order on the LED display\n        basic.showString(\"Door:\" + delyDoor)\n\n        // Start the countdown during \"delyTime\" seconds\n        countdown(delyTime)\n\n        // The countdown function ended.\n        // was the order delivered?  \n        // Check if you delivered the pizza (or not) \n        if (orderActive == true){\n            // The order remains pending. I am very sorry for you >:-D\n            deliveryFail() // booom!!!\n        }\n    } else { // This ELSE comes from above if (mCourierId == myID) \n        // The order is not for me (fiuuuuu)\n        basic.pause(1000)\n        // Show I add a point\n        basic.showString(\"+1\")\n    }\n}\n\n// === Inputs handlers ===\n// This function executes when the button A is pressed\ninput.onButtonPressed(Button.A, function () {\n    // deliver the order to door \"A\"\n    deliverTo(\"A\"); // Use \"A\", not A\n})\n\n// =======================================\n// ========= Task: 5\n// =======================================\n// TODO: add an input function to process the input Button B\ninput.onButtonPressed(Button.B, function () {\n    // deliver the order to door \"B\".\n    // HINT: it is almost identical to the Button A input function\n})\n\n// TODO: add an input function to process the Pin 0\ninput.onPinPressed(TouchPin.P0, function () {\n    // deliver the order to door \"0\"\n    deliverTo(\"0\");\n})\n\n// TODO: add an input function to process the Pin 1\ninput.onPinPressed(TouchPin.P1, function () {\n    // deliver the order to door \"1\"\n    // HINT: it is almost identical to the P0 input function\n})\n\n// TODO: add an input function to process the Pin 2\ninput.onPinPressed(TouchPin.P2, function () {\n    // deliver the order to door \"2\"\n    // HINT: it is almost identical to the P0 input function\n})\n\n\n// === Helper: Handle Delivery Attempt ===\nfunction deliverTo(ringPressed: string) {\n    // Check if the game is over.\n    if (gameOver == true) \n    { // If the game is over, there is nothing to do\n        return // end of function\n    }\n\n    // NOTE: If you are reading this after the if gameOver validation, it means that\n    //       the game is not over. We keep delivering the order!\n    // The game is not over. Check if the order is active\n    if (orderActive == true) \n    {   // The order is active! \n        // Check if delivered correctly. Door must equal ringbell\n// =======================================\n// ========= Task: 6\n// =======================================\n// TODO: Check if you pressed the right ringbell\n    if (false){\n        // order delivered correctly. Well done!\n            deliveryOK()\n        } else {\n            // order is not delivered ok. I am very sorry for you :-p\n            deliveryFail()\n        }\n    }\n}\n\n// === Logo pressed: Create a pizza order ===\ninput.onLogoEvent(TouchButtonEvent.Pressed, createOrder)\n\nfunction createOrder() {\n    // Not create order if there is another order active already\n    if (orderActive == true) return;\n    // Not create order if the game is over already\n    if (gameOver == true) return;\n    const now = control.millis()\n    if (now - lastSendTime > cooldownTimer * 1000) {\n        lastSendTime = now\n// =======================================\n// ========= Task: 7\n// =======================================\n// TODO: Create an order, prepare the order, and send the order.\n\n    } else {\n        basic.showIcon(IconNames.Chessboard)\n        basic.pause(200)\n    }\n}\n\n\n// === Helper: prepare Order ===\nfunction prepareOrder():string {\n// We need to prepare the order message before sending it.\n    // The message is comprised of several parts separated by a :\n    // Consider the following example\n    // - Type of message = order\n    // - courierID = 12\n    // - door = B\n    // - DelyTime = 5 seconds\n    // Combining all the data,\n    // you can CODIFY a message as order:12:B:5\n    \n// Let's start by creating our variables. The m in the name says is for messaging\n    let mTypeMessage = \"order\"\n    let mCourierID;        // the courier destination\n    let mDoor;             // the door to deliver the order\n    let mDelyTime         // the time left to deliver the order\n    let mSeparator = \":\"  // a separator, to not mix the data\n    let message: string   // The message with the full order\n\n// Choose a courier to send the order\n    do { // Choose a random courier ID\n        mCourierID = randint(1, players)\n    } while (mCourierID == myID); // This checks that you don't send the order to yourself\n\n// Choose a random door\n    // We choose a random option from all the ringbellPanel chances\n    let ringbellOption = randint(0, ringbellPanel.length - 1)\n    // we use the option to choose from the ringbell panel\n    mDoor = ringbellPanel[ringbellOption]\n\n// Choose a delivery time\n    // Use the default delivery time\n    mDelyTime = defaultDelyTime\n\n// Show the targetID on screen (and play some sound)   \n    basic.showString(\"To:\" + mCourierID)\n    music.play(music.builtinPlayableSoundEffect(soundExpression.hello), music.PlaybackMode.InBackground)\n\n// Assembly all the parts in a single message\n// =======================================\n// ========= Task: 8\n// =======================================\n    // TODO: concatenate the parts into a single message.\n    //       Intercalate : in between as a separator\n    message = \"\" // concatenate + \":\" + the \":\" +  parts ;-)\n\n// return the order\n    // The message order is ready! return the message\n    return message;\n}\n\nfunction sendOrder(message: string){\n    // send the message by radio!\n// =======================================\n// ========= Task: 9\n// =======================================\n    // TODO: use the message to broadcast by radio\n    radio.sendString(\"your order here\")\n}\n\n","README.md":"","backend.ts":"/****************************************************************************************\n * Project: Micro:bit Multiplayer Game\n * Description: Core logic and custom extensions for micro:bit multiplayer interaction.\n * \n * File: backend.ts\n * Contains: Helper functions to aliviate students' work\n * \n * Author: Sebastian Barillaro\n * Date: 2025-06-01\n * Platform: Microsoft MakeCode for micro:bit\n * \n * Notes:\n * - Designed for use with MakeCode editor (https://makecode.microbit.org/)\n * - Compatible with MakeCode's TypeScript (pxt) environment\n * \n * License: Reserved for Luxembourg Tech School ASBL\n ****************************************************************************************/\n\n\nlet lastSendTime = 0\nconst cooldownTimer = 10 //seconds\n\n// === Helper: Show current status (ID + Score) ===\nfunction showStatus() {\n    // Show ID and myScore on the LED display\n    basic.showString(\"ID:\" + myID + \" S:\" + myScore)\n}\nfunction startGame() {\n    // play starting sound\n    music.play(music.builtinPlayableSoundEffect(soundExpression.happy), music.PlaybackMode.InBackground)\n    // show the status!\n    showStatus()\n}\n\n// This function configures the device to end the game\nfunction endGame() {\n    // Set the flag gameOver \n    gameOver = true\n    // Deactivate any order\n    orderActive = false\n    //Stop the sound\n    music.stopAllSounds()\n    // Show the NO icon during 1 second (a visual reference)\n    basic.showIcon(IconNames.Ghost)\n    basic.pause(1000)\n    // show the final score on screen\n    showStatus()\n}\n\nfunction announceOrder(){\n    basic.showIcon(IconNames.Surprised)\n    \n    music._playDefaultBackground(music.builtInPlayableMelody(Melodies.BaDing), music.PlaybackMode.UntilDone)\n    // All players get a point for surviving this round\n    myScore++\n}\n\n\n\nfunction countdown(delyTime: number) {\n    for (let i = 0; i <= delyTime - 1; i++) {\n        music.playTone(262, 100)\n        // basic.showIcon(IconNames.Heart)\n        basic.showNumber(delyTime - i)\n        basic.pause(400)\n        music.playTone(349, 100)\n        basic.clearScreen()\n        basic.pause(400)\n        if (orderActive == false) {\n            break;\n        }\n    }\n}\n\n\n// === Helper: order delivered correctly ===\nfunction deliveryOK() {\n    orderActive = false\n    myScore += 5\n    music.stopAllSounds()\n    basic.showIcon(IconNames.Yes)\n    basic.pause(1000)\n    showStatus()\n}\n\n// === Helper: Bomb Exploded ===\nfunction deliveryFail() {\n    orderActive = false\n    myScore = Math.max(0, myScore - 5)\n    music.stopAllSounds()\n    music.startMelody([\"C5\", \"B\", \"A\", \"G\", \"F\", \"E\", \"D\", \"C\"], MelodyOptions.Once)\n    basic.showIcon(IconNames.Skull)\n    basic.pause(1000)\n    showStatus()\n}\n\n","master.ts":"","pxt.json":"{\n    \"name\": \"fast-flourrious-T1\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\"\n    },\n    \"files\": [\n        \"main.ts\",\n        \"README.md\",\n        \"backend.ts\",\n        \"master.ts\"\n    ],\n    \"testFiles\": [\n        \"test.ts\"\n    ],\n    \"targetVersions\": {\n        \"target\": \"7.0.61\",\n        \"targetId\": \"microbit\"\n    },\n    \"supportedTargets\": [\n        \"microbit\"\n    ],\n    \"preferredEditor\": \"tsprj\",\n    \"languageRestriction\": \"javascript-only\"\n}\n","test.ts":"// tests go here; this will not be compiled when this package is used as an extension.\n"}},{"timestamp":1749682259378,"editorVersion":"7.0.61","text":{"main.ts":"/****************************************************************************************\n * Project: Micro:bit Multiplayer Game\n * Description: Core logic and custom extensions for micro:bit multiplayer interaction.\n * \n * File: main.ts\n * Contains: Main logic. Task 1\n * \n * Author: Sebastian Barillaro\n * Date: 2025-06-10\n * Platform: Microsoft MakeCode for micro:bit\n * \n * Notes:\n * - Designed for use with MakeCode editor (https://makecode.microbit.org/)\n * - Compatible with MakeCode's TypeScript (pxt) environment\n * \n * License: Reserved for Luxembourg Tech School ASBL\n ****************************************************************************************/\n\n\n// === Constants ===\nconst defaultDelyTime = 6  // seconds\nconst defaultRadioGroup = 10\nconst mGameOver = \"gameOver\"\n\n// === Flag Variables ===\nlet orderActive = false // false = order not active ; true = order activated!\nlet gameOver = false // false = game is NOT over (playing) ; true = the game is over.\n\n// === Support Variables ===\nlet delyDoor = \"\"\nlet delyTime = defaultDelyTime;\nlet myScore = 0\n\n// === Configuration variables ===\n// =======================================\n// ========= Task: \n// =======================================\n// TODO: Set printMessage to false to stop showing the message on the LED display\n// print radio Message\nlet printMessage = true;\n\n// Set the number of players!\nlet players = 20;\n// Set your ID (Must be unique in your group)\nlet myID = randint(1, players); // Change the random value for something fix\n// Set the difficulty of the game: \"easy\", (more to come later)\nlet difficulty = \"easy\";\n// Set the ringbell options list\nlet ringbellPanel = [\"A\", \"B\", \"0\", \"1\", \"2\"]\n\n\n// =======================================\n// ========= Task 1:\n// =======================================\n// Configure the radio Group\n// TODO: radio.setGroup(use the radioGroup here)\nradio.setGroup(defaultRadioGroup)\n// start the game!\n// TODO: Call the startGame function\nstartGame()\n\n// === Receive Radio Message ===\n// This function executes when the device receives a radio message.\nradio.onReceivedString(radioMessageReceived)\n\n// === handler of the reception ===\nfunction radioMessageReceived(message: string) {\n    music.playTone(262, 100)\n\n    // You have received a radio message. We will print it on the display\n    if (printMessage == true){\n        basic.showString(message);\n    }\n\n    // If the game is over, we do nothing (return)\n    if (gameOver == true) {\n        // Show the NO icon during 1 second (a visual reference)\n        basic.showIcon(IconNames.Ghost)\n        basic.pause(1000)\n        return // This return instruction ends the function. \n               // It continues where it was called from\n    }\n\n    // The game is not over. Let's see what we have received\n// =======================================\n// ========= Task: 2\n// =======================================\n// TODO: check if the message received is equal to \"gameOver\"\n   if (message == \"gameOver\") {\n        // The message received indicates to end the game\n        endGame()\n        // return makes the function end\n        return;\n    }\n\n    // The header of the message indicates what type of message is\n    // Let's extract the header of the message\n    let header = message.substr(0, 5) // this line extracts the first 5 letters\n// =======================================\n// ========= Task: 3\n// =======================================\n// TODO: Check if the header of the message is \"order\"\n    if (header == \"order\") {\n        // The message is of type order!\n        // Just a visual representation\n        announceOrder();\n        // Decode the message to obtain the information\n        let messageInfo = decode(message);\n        //Process the order message information!\n        processOrderMessage(messageInfo)\n    }\n}\n\nfunction decode(message:string){\n    // The message received has four parts: order, Courier ID, ring bell, and delivery time.\n    // All the parts are together, separated by a :\n    // For example order:5:B:6\n    // We store the fields in variables starting with m (m for message)\n    let mType = \"\";\n    let mCourierId = 0;\n    let mDelyDoor = \"\";\n    let mDelyTime = 0;\n    let mParts = [];\n    // =======================================\n    // ========= Task: 4\n    // =======================================\n    //TODO: split the message by the separator :\n    //      take the message parts (0, 1, 2, and 3) in separated \n    //      variables (mType, mCourierId, mDelyDoor, mDelyTime)\n    // We need to split the parts by the separator\n    mParts = message.split(\":\")\n    mType = mParts[0];\n    mCourierId = parseInt(mParts[1]);\n    // mDelyDoor = mParts[2];\n    // mDelyTime = parseInt(mParts[3]);\n\n    // Return a structure with all the message information\n    return {\n        type: mType,\n        courierId: mCourierId,\n        delyDoor: mDelyDoor,\n        delyTime: mDelyTime\n    };\n}\n\nfunction processOrderMessage(messageInfo:any) {\n    // messageInfo has all the information of the message\n    // Use the information to decide what to do next\n\n    // Check if the order was sent to me :-O\n    if (messageInfo.CourierId == myID) {\n        // Caramba!! The order is for me!!!\n        // mark the flag order active!\n        orderActive = true\n        // save the message info into the micro:bit memory\n        delyDoor = messageInfo.DelyDoor\n        delyTime = messageInfo.DelyTime\n\n        // Show the door to deliver the order on the LED display\n        basic.showString(\"Door:\" + delyDoor)\n\n        // Start the countdown during \"delyTime\" seconds\n        countdown(delyTime)\n\n        // The countdown function ended.\n        // was the order delivered?  \n        // Check if you delivered the pizza (or not) \n        if (orderActive == true){\n            // The order remains pending. I am very sorry for you >:-D\n            deliveryFail() // booom!!!\n        }\n    } else { // This ELSE comes from above if (messageInfo.CourierId == myID)\n        // The order is not for me (fiuuuuu)\n        basic.pause(1000)\n        // Show I add a point\n        basic.showString(\"+1\")\n    }\n}\n\n// === Inputs handlers ===\n// This function executes when the button A is pressed\ninput.onButtonPressed(Button.A, function () {\n    // deliver the order to door \"A\"\n    deliverTo(\"A\"); // Use \"A\", not A\n})\n\n// This function executes when the button B is pressed\ninput.onButtonPressed(Button.B, function () {\n    // deliver the order to door \"B\".\n    deliverTo(\"B\"); // Use \"B\", not B\n})\n\n// This function executes when the pin 0 is closed\ninput.onPinPressed(TouchPin.P0, function () {\n    // deliver the order to door \"0\"\n    deliverTo(\"0\");\n})\n\n// This function executes when the pin 1 is closed\ninput.onPinPressed(TouchPin.P1, function () {\n    // deliver the order to door \"1\"\n    deliverTo(\"1\");\n})\n\n// This function executes when the pin 2 is closed\ninput.onPinPressed(TouchPin.P2, function () {\n    // deliver the order to door \"2\"\n    deliverTo(\"2\");\n})\n\n\n// === Helper: Handle Delivery Attempt ===\nfunction deliverTo(ringPressed: string) {\n    // Check if the game is over.\n    if (gameOver == true) \n    { // If the game is over, there is nothing to do\n        return // end of function\n    }\n\n    // NOTE: If you are reading this after the if gameOver validation, it means that\n    //       the game is not over. We keep delivering the order!\n    // The game is not over. Check if the order is active\n    if (orderActive == true) {\n        // The order is active! \n        // Check if delivered correctly. Door must equal ringbell\n        if (delyDoor == ringPressed){\n            // order delivered correctly. Well done!\n            deliveryOK()\n        } else {\n            // order is not delivered ok. I am very sorry for you :-p\n            deliveryFail()\n        }\n    }\n}\n\n// === Logo pressed: Create a pizza order ===\ninput.onLogoEvent(TouchButtonEvent.Pressed, createOrder)\n\nfunction createOrder() {\n    // Not create order if there is another order active already\n    if (orderActive == true) return;\n    // Not create order if the game is over already\n    if (gameOver == true) return;\n    const now = control.millis()\n    if (now - lastSendTime > cooldownTimer * 1000) {\n        lastSendTime = now\n// =======================================\n// ========= Task: 7\n// =======================================\n        let message = \"\"\n        // TODO: use encodeInfo funtion to create a message\n        // message = encodeInfo();\n        // TODO: use sendMessage function to send the message\n        // sendMessage(message);\n    } else {\n        basic.showIcon(IconNames.Chessboard)\n        basic.pause(200)\n    }\n}\n\n\n// === Helper: prepare Order ===\nfunction encodeInfo():string {\n// We need to prepare the order message before sending it.\n    // The message is comprised of several parts separated by a :\n    // Consider the following example\n    // - Type of message = order\n    // - courierID = 12\n    // - door = B\n    // - DelyTime = 5 seconds\n    // Combining all the data,\n    // you can CODIFY a message as order:12:B:5\n    \n// Let's start by creating our variables. The m in the name says is for messaging\n    let mTypeMessage = \"order\"\n    let mCourierID;        // the courier destination\n    let mDoor;             // the door to deliver the order\n    let mDelyTime         // the time left to deliver the order\n    let mSeparator = \":\"  // a separator, to not mix the data\n    let message: string   // The message with the full order\n\n// Choose a courier to send the order\n    do { // Choose a random courier ID\n        mCourierID = randint(1, players)\n    } while (mCourierID == myID); // This checks that you don't send the order to yourself\n\n// Choose a random door\n    // We choose a random option from all the ringbellPanel chances\n    let ringbellOption = randint(0, ringbellPanel.length - 1)\n    // we use the option to choose from the ringbell panel\n    mDoor = ringbellPanel[ringbellOption]\n\n// Choose a delivery time\n    // Use the default delivery time\n    mDelyTime = defaultDelyTime\n\n// Show the targetID on screen (and play some sound)   \n    basic.showString(\"To:\" + mCourierID)\n    music.play(music.builtinPlayableSoundEffect(soundExpression.hello), music.PlaybackMode.InBackground)\n\n// Assembly all the parts in a single message\n// =======================================\n// ========= Task: 5\n// =======================================\n    // TODO: concatenate the parts into a single message.\n    //       Intercalate : in between as a separator\n    message = \"\" // concatenate + \":\" + the \":\" +  parts ;-)\n\n    // return the message\n    // The message order is ready! return the message\n    return message;\n}\n\nfunction sendMessage(message: string){\n    // send the message by radio!\n// =======================================\n// ========= Task: 6\n// =======================================\n    // TODO: use the message to broadcast by radio\n    radio.sendString(\"\")\n}\n\n","README.md":"","backend.ts":"/****************************************************************************************\n * Project: Micro:bit Multiplayer Game\n * Description: Core logic and custom extensions for micro:bit multiplayer interaction.\n * \n * File: backend.ts\n * Contains: Helper functions to aliviate students' work\n * \n * Author: Sebastian Barillaro\n * Date: 2025-06-01\n * Platform: Microsoft MakeCode for micro:bit\n * \n * Notes:\n * - Designed for use with MakeCode editor (https://makecode.microbit.org/)\n * - Compatible with MakeCode's TypeScript (pxt) environment\n * \n * License: Reserved for Luxembourg Tech School ASBL\n ****************************************************************************************/\n\n\nlet lastSendTime = 0\nconst cooldownTimer = 10 //seconds\n\n// === Helper: Show current status (ID + Score) ===\nfunction showStatus() {\n    // Show ID and myScore on the LED display\n    basic.showString(\"ID:\" + myID + \" S:\" + myScore)\n}\nfunction startGame() {\n    // play starting sound\n    music.play(music.builtinPlayableSoundEffect(soundExpression.happy), music.PlaybackMode.InBackground)\n    // show the status!\n    showStatus()\n}\n\n// This function configures the device to end the game\nfunction endGame() {\n    // Set the flag gameOver \n    gameOver = true\n    // Deactivate any order\n    orderActive = false\n    //Stop the sound\n    music.stopAllSounds()\n    // Show the NO icon during 1 second (a visual reference)\n    basic.showIcon(IconNames.Ghost)\n    basic.pause(1000)\n    // show the final score on screen\n    showStatus()\n}\n\nfunction announceOrder(){\n    basic.showIcon(IconNames.Surprised)\n    \n    music._playDefaultBackground(music.builtInPlayableMelody(Melodies.BaDing), music.PlaybackMode.UntilDone)\n    // All players get a point for surviving this round\n    myScore++\n}\n\n\n\nfunction countdown(delyTime: number) {\n    for (let i = 0; i <= delyTime - 1; i++) {\n        music.playTone(262, 100)\n        // basic.showIcon(IconNames.Heart)\n        basic.showNumber(delyTime - i)\n        basic.pause(400)\n        music.playTone(349, 100)\n        basic.clearScreen()\n        basic.pause(400)\n        if (orderActive == false) {\n            break;\n        }\n    }\n}\n\n\n// === Helper: order delivered correctly ===\nfunction deliveryOK() {\n    orderActive = false\n    myScore += 5\n    music.stopAllSounds()\n    basic.showIcon(IconNames.Yes)\n    basic.pause(1000)\n    showStatus()\n}\n\n// === Helper: Delivery Fail ===\nfunction deliveryFail() {\n    orderActive = false\n    myScore = Math.max(0, myScore - 5)\n    music.stopAllSounds()\n    music.startMelody([\"C5\", \"B\", \"A\", \"G\", \"F\", \"E\", \"D\", \"C\"], MelodyOptions.Once)\n    basic.showIcon(IconNames.Skull)\n    basic.pause(1000)\n    showStatus()\n}\n\n","master.ts":"","pxt.json":"{\n    \"name\": \"fast-flourrious-T1\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\"\n    },\n    \"files\": [\n        \"main.ts\",\n        \"README.md\",\n        \"backend.ts\",\n        \"master.ts\"\n    ],\n    \"testFiles\": [\n        \"test.ts\"\n    ],\n    \"targetVersions\": {\n        \"target\": \"7.0.61\",\n        \"targetId\": \"microbit\"\n    },\n    \"supportedTargets\": [\n        \"microbit\"\n    ],\n    \"preferredEditor\": \"tsprj\",\n    \"languageRestriction\": \"javascript-only\"\n}\n","test.ts":"// tests go here; this will not be compiled when this package is used as an extension.\n"}},{"timestamp":1749713238737,"editorVersion":"7.0.61","text":{"main.ts":"/****************************************************************************************\n * Project: Micro:bit Multiplayer Game\n * Description: Core logic and custom extensions for micro:bit multiplayer interaction.\n * \n * File: main.ts\n * Contains: Main logic. Task 1\n * \n * Author: Sebastian Barillaro\n * Date: 2025-06-10\n * Platform: Microsoft MakeCode for micro:bit\n * \n * Notes:\n * - Designed for use with MakeCode editor (https://makecode.microbit.org/)\n * - Compatible with MakeCode's TypeScript (pxt) environment\n * \n * License: Reserved for Luxembourg Tech School ASBL\n ****************************************************************************************/\n\n\n// === Constants ===\nconst defaultDelyTime = 6  // seconds\nconst defaultRadioGroup = 10\nconst mGameOver = \"gameOver\"\n\n// === Flag Variables ===\nlet orderActive = false // false = order not active ; true = order activated!\nlet gameOver = false // false = game is NOT over (playing) ; true = the game is over.\n\n// === Support Variables ===\nlet delyDoor = \"\"\nlet delyTime = defaultDelyTime;\nlet myScore = 0\n\n// === Configuration variables ===\n// =======================================\n// ========= Task: \n// =======================================\n// TODO: Set printMessage to false to stop showing the message on the LED display\n// print radio Message\nlet printMessage = true;\n\n// Set the number of players!\nlet players = 20;\n// Set your ID (Must be unique in your group)\nlet myID = randint(1, players); // Change the random value for something fix\n// Set the difficulty of the game: \"easy\", (more to come later)\nlet difficulty = \"easy\";\n// Set the ringbell options list\nlet ringbellPanel = [\"A\", \"B\", \"0\", \"1\", \"2\"]\n\n\n// =======================================\n// ========= Task 1:\n// =======================================\n// Configure the radio Group\n// TODO: radio.setGroup(use the radioGroup here)\nradio.setGroup(defaultRadioGroup)\n// start the game!\n// TODO: Call the startGame function\nstartGame()\n\n// === Receive Radio Message ===\n// This function executes when the device receives a radio message.\nradio.onReceivedString(radioMessageReceived)\n\n// === handler of the reception ===\nfunction radioMessageReceived(message: string) {\n    music.playTone(262, 100)\n\n    // You have received a radio message. We will print it on the display\n    if (printMessage == true){\n        basic.showString(message);\n    }\n\n    // If the game is over, we do nothing (return)\n    if (gameOver == true) {\n        // Show the NO icon during 1 second (a visual reference)\n        basic.showIcon(IconNames.Ghost)\n        basic.pause(1000)\n        return // This return instruction ends the function. \n               // It continues where it was called from\n    }\n\n    // The game is not over. Let's see what we have received\n// =======================================\n// ========= Task: 2\n// =======================================\n// TODO: check if the message received is equal to \"gameOver\"\n   if (message == \"gameOver\") {\n        // The message received indicates to end the game\n        endGame()\n        // return makes the function end\n        return;\n    }\n\n    // The header of the message indicates what type of message is\n    // Let's extract the header of the message\n    let header = message.substr(0, 5) // this line extracts the first 5 letters\n// =======================================\n// ========= Task: 3\n// =======================================\n// TODO: Check if the header of the message is \"order\"\n    if (header == \"order\") {\n        // The message is of type order!\n        // Just a visual representation\n        announceOrder();\n        // Decode the message to obtain the information\n        let messageInfo = decode(message);\n        //Process the order message information!\n        processOrderMessage(messageInfo)\n    }\n}\n\nfunction decode(message:string){\n    // The message received has four parts: order, Courier ID, ring bell, and delivery time.\n    // All the parts are together, separated by a :\n    // For example order:5:B:6\n    // We store the fields in variables starting with m (m for message)\n    let mType = \"\";\n    let mCourierId = 0;\n    let mDelyDoor = \"\";\n    let mDelyTime = 0;\n    let mParts = [];\n    // =======================================\n    // ========= Task: 4\n    // =======================================\n    //TODO: split the message by the separator :\n    //      take the message parts (0, 1, 2, and 3) in separated \n    //      variables (mType, mCourierId, mDelyDoor, mDelyTime)\n    // We need to split the parts by the separator\n    mParts = message.split(\":\")\n    mType = mParts[0];\n    mCourierId = parseInt(mParts[1]);\n    // mDelyDoor = mParts[2];\n    // mDelyTime = parseInt(mParts[3]);\n\n    // Return a structure with all the message information\n    return {\n        type: mType,\n        courierId: mCourierId,\n        delyDoor: mDelyDoor,\n        delyTime: mDelyTime\n    };\n}\n\nfunction processOrderMessage(messageInfo:any) {\n    // messageInfo has all the information of the message\n    // Use the information to decide what to do next\n\n    // Check if the order was sent to me :-O\n    if (messageInfo.CourierId == myID) {\n        // Caramba!! The order is for me!!!\n        // mark the flag order active!\n        orderActive = true\n        // save the message info into the micro:bit memory\n        delyDoor = messageInfo.DelyDoor\n        delyTime = messageInfo.DelyTime\n\n        // Show the door to deliver the order on the LED display\n        basic.showString(\"Door:\" + delyDoor)\n\n        // Start the countdown during \"delyTime\" seconds\n        countdown(delyTime)\n\n        // The countdown function ended.\n        // was the order delivered?  \n        // Check if you delivered the pizza (or not) \n        if (orderActive == true){\n            // The order remains pending. I am very sorry for you >:-D\n            deliveryFail() // booom!!!\n        }\n    } else { // This ELSE comes from above if (messageInfo.CourierId == myID)\n        // The order is not for me (fiuuuuu)\n        basic.pause(1000)\n        // Show I add a point\n        basic.showString(\"+1\")\n    }\n}\n\n// === Inputs handlers ===\n// This function executes when the button A is pressed\ninput.onButtonPressed(Button.A, function () {\n    // deliver the order to door \"A\"\n    deliverTo(\"A\"); // Use \"A\", not A\n})\n\n// This function executes when the button B is pressed\ninput.onButtonPressed(Button.B, function () {\n    // deliver the order to door \"B\".\n    deliverTo(\"B\"); // Use \"B\", not B\n})\n\n// This function executes when the pin 0 is closed\ninput.onPinPressed(TouchPin.P0, function () {\n    // deliver the order to door \"0\"\n    deliverTo(\"0\");\n})\n\n// This function executes when the pin 1 is closed\ninput.onPinPressed(TouchPin.P1, function () {\n    // deliver the order to door \"1\"\n    deliverTo(\"1\");\n})\n\n// This function executes when the pin 2 is closed\ninput.onPinPressed(TouchPin.P2, function () {\n    // deliver the order to door \"2\"\n    deliverTo(\"2\");\n})\n\n\n// === Helper: Handle Delivery Attempt ===\nfunction deliverTo(ringPressed: string) {\n    // Check if the game is over.\n    if (gameOver == true) \n    { // If the game is over, there is nothing to do\n        return // end of function\n    }\n\n    // NOTE: If you are reading this after the if gameOver validation, it means that\n    //       the game is not over. We keep delivering the order!\n    // The game is not over. Check if the order is active\n    if (orderActive == true) {\n        // The order is active! \n        // Check if delivered correctly. Door must equal ringbell\n        if (delyDoor == ringPressed){\n            // order delivered correctly. Well done!\n            deliveryOK()\n        } else {\n            // order is not delivered ok. I am very sorry for you :-p\n            deliveryFail()\n        }\n    }\n}\n\n// === Logo pressed: Create a pizza order ===\ninput.onLogoEvent(TouchButtonEvent.Pressed, createOrder)\n\nfunction createOrder() {\n    // Not create order if there is another order active already\n    if (orderActive == true) return;\n    // Not create order if the game is over already\n    if (gameOver == true) return;\n    const now = control.millis()\n    if (now - lastSendTime > cooldownTimer * 1000) {\n        lastSendTime = now\n// =======================================\n// ========= Task: 7\n// =======================================\n        let message = \"\"\n        // TODO: use encodeInfo funtion to create a message\n        // message = encodeInfo();\n        // TODO: use sendMessage function to send the message\n        // sendMessage(message);\n    } else {\n        basic.showIcon(IconNames.Chessboard)\n        basic.pause(200)\n    }\n}\n\n\n// === Helper: prepare Order ===\nfunction encodeInfo():string {\n// We need to prepare the order message before sending it.\n    // The message is comprised of several parts separated by a :\n    // Consider the following example\n    // - Type of message = order\n    // - courierID = 12\n    // - door = B\n    // - DelyTime = 5 seconds\n    // Combining all the data,\n    // you can CODIFY a message as order:12:B:5\n    \n// Let's start by creating our variables. The m in the name says is for messaging\n    let mType = \"order\"\n    let mCourierID;        // the courier destination\n    let mDoor;             // the door to deliver the order\n    let mDelyTime         // the time left to deliver the order\n    let mSeparator = \":\"  // a separator, to not mix the data\n    let message: string   // The message with the full order\n\n// Choose a courier to send the order\n    do { // Choose a random courier ID\n        mCourierID = randint(1, players)\n    } while (mCourierID == myID); // This checks that you don't send the order to yourself\n\n// Choose a random door\n    // We choose a random option from all the ringbellPanel chances\n    let ringbellOption = randint(0, ringbellPanel.length - 1)\n    // we use the option to choose from the ringbell panel\n    mDoor = ringbellPanel[ringbellOption]\n\n// Choose a delivery time\n    // Use the default delivery time\n    mDelyTime = defaultDelyTime\n\n// Show the targetID on screen (and play some sound)   \n    basic.showString(\"To:\" + mCourierID)\n    music.play(music.builtinPlayableSoundEffect(soundExpression.hello), music.PlaybackMode.InBackground)\n\n// Encode the information to create a message\n// =======================================\n// ========= Task: 5\n// =======================================\n    // TODO: concatenate the parts of information into a message.\n    //       Intercalate : in between as a separator\n    message = \"\" // concatenate + \":\" + the \":\" +  parts ;-)\n\n    // return the message\n    // The message order is ready! return the message\n    return message;\n}\n\nfunction sendMessage(message: string){\n    // send the message by radio!\n// =======================================\n// ========= Task: 6\n// =======================================\n    // TODO: use the radio.sendString function to send the message by radio\n    radio.sendString(\"\")\n}\n\n","README.md":"","backend.ts":"/****************************************************************************************\n * Project: Micro:bit Multiplayer Game\n * Description: Core logic and custom extensions for micro:bit multiplayer interaction.\n * \n * File: backend.ts\n * Contains: Helper functions to aliviate students' work\n * \n * Author: Sebastian Barillaro\n * Date: 2025-06-01\n * Platform: Microsoft MakeCode for micro:bit\n * \n * Notes:\n * - Designed for use with MakeCode editor (https://makecode.microbit.org/)\n * - Compatible with MakeCode's TypeScript (pxt) environment\n * \n * License: Reserved for Luxembourg Tech School ASBL\n ****************************************************************************************/\n\n\nlet lastSendTime = 0\nconst cooldownTimer = 10 //seconds\n\n// === Helper: Show current status (ID + Score) ===\nfunction showStatus() {\n    // Show ID and myScore on the LED display\n    basic.showString(\"ID:\" + myID + \" S:\" + myScore)\n}\nfunction startGame() {\n    // play starting sound\n    music.play(music.builtinPlayableSoundEffect(soundExpression.happy), music.PlaybackMode.InBackground)\n    // show the status!\n    showStatus()\n}\n\n// This function configures the device to end the game\nfunction endGame() {\n    // Set the flag gameOver \n    gameOver = true\n    // Deactivate any order\n    orderActive = false\n    //Stop the sound\n    music.stopAllSounds()\n    // Show the NO icon during 1 second (a visual reference)\n    basic.showIcon(IconNames.Ghost)\n    basic.pause(1000)\n    // show the final score on screen\n    showStatus()\n}\n\nfunction announceOrder(){\n    basic.showIcon(IconNames.Surprised)\n    \n    music._playDefaultBackground(music.builtInPlayableMelody(Melodies.BaDing), music.PlaybackMode.UntilDone)\n    // All players get a point for surviving this round\n    myScore++\n}\n\n\n\nfunction countdown(delyTime: number) {\n    for (let i = 0; i <= delyTime - 1; i++) {\n        music.playTone(262, 100)\n        // basic.showIcon(IconNames.Heart)\n        basic.showNumber(delyTime - i)\n        basic.pause(400)\n        music.playTone(349, 100)\n        basic.clearScreen()\n        basic.pause(400)\n        if (orderActive == false) {\n            break;\n        }\n    }\n}\n\n\n// === Helper: order delivered correctly ===\nfunction deliveryOK() {\n    orderActive = false\n    myScore += 5\n    music.stopAllSounds()\n    basic.showIcon(IconNames.Yes)\n    basic.pause(1000)\n    showStatus()\n}\n\n// === Helper: Delivery Fail ===\nfunction deliveryFail() {\n    orderActive = false\n    myScore = Math.max(0, myScore - 5)\n    music.stopAllSounds()\n    music.startMelody([\"C5\", \"B\", \"A\", \"G\", \"F\", \"E\", \"D\", \"C\"], MelodyOptions.Once)\n    basic.showIcon(IconNames.Skull)\n    basic.pause(1000)\n    showStatus()\n}\n\n","master.ts":"","pxt.json":"{\n    \"name\": \"fast-flourrious-T1\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\"\n    },\n    \"files\": [\n        \"main.ts\",\n        \"README.md\",\n        \"backend.ts\",\n        \"master.ts\"\n    ],\n    \"testFiles\": [\n        \"test.ts\"\n    ],\n    \"targetVersions\": {\n        \"target\": \"7.0.61\",\n        \"targetId\": \"microbit\"\n    },\n    \"supportedTargets\": [\n        \"microbit\"\n    ],\n    \"preferredEditor\": \"tsprj\",\n    \"languageRestriction\": \"javascript-only\"\n}\n","test.ts":"// tests go here; this will not be compiled when this package is used as an extension.\n"}},{"timestamp":1749717393471,"editorVersion":"7.0.61","text":{"main.ts":"/****************************************************************************************\n * Project: Micro:bit Multiplayer Game\n * Description: Core logic and custom extensions for micro:bit multiplayer interaction.\n * \n * File: main.ts\n * Contains: Main logic. Task 1\n * \n * Author: Sebastian Barillaro\n * Date: 2025-06-10\n * Platform: Microsoft MakeCode for micro:bit\n * \n * Notes:\n * - Designed for use with MakeCode editor (https://makecode.microbit.org/)\n * - Compatible with MakeCode's TypeScript (pxt) environment\n * \n * License: Reserved for Luxembourg Tech School ASBL\n ****************************************************************************************/\n\n\n// === Constants ===\nconst defaultDelyTime = 6  // seconds\nconst defaultRadioGroup = 10\nconst mGameOver = \"gameOver\"\n\n// === Flag Variables ===\nlet orderActive = false // false = order not active ; true = order activated!\nlet gameOver = false // false = game is NOT over (playing) ; true = the game is over.\n\n// === Support Variables ===\nlet delyDoor = \"\"\nlet delyTime = defaultDelyTime;\nlet myScore = 0\n\n// === Configuration variables ===\n// =======================================\n// ========= Task: \n// =======================================\n// TODO: Set printMessage to false to stop showing the message on the LED display\n// print radio Message\nlet printMessage = true;\n\n// Set the number of players!\nlet players = 20;\n// Set your ID (Must be unique in your group)\nlet myID = randint(1, players); // Change the random value for something fix\n// Set the difficulty of the game: \"easy\", (more to come later)\nlet difficulty = \"easy\";\n// Set the ringbell options list\nlet ringbellPanel = [\"A\", \"B\", \"0\", \"1\", \"2\"]\n\n\n// =======================================\n// ========= Task 1:\n// =======================================\n// Configure the radio Group\n// TODO: radio.setGroup(use the radioGroup here)\n// start the game!\n// TODO: Call the startGame function\n\n// === Receive Radio Message ===\n// This function executes when the device receives a radio message.\nradio.onReceivedString(radioMessageReceived)\n\n// === handler of the reception ===\nfunction radioMessageReceived(message: string) {\n    music.playTone(262, 100)\n\n    // You have received a radio message. We will print it on the display\n    if (printMessage == true){\n        basic.showString(message);\n    }\n\n    // If the game is over, we do nothing (return)\n    if (gameOver == true) {\n        // Show the NO icon during 1 second (a visual reference)\n        basic.showIcon(IconNames.Ghost)\n        basic.pause(1000)\n        return // This return instruction ends the function. \n               // It continues where it was called from\n    }\n\n    // The game is not over. Let's see what we have received\n// =======================================\n// ========= Task: 2\n// =======================================\n// TODO: check if the message received is equal to \"gameOver\"\n   if (message == \"gameOver\") {\n        // The message received indicates to end the game\n        endGame()\n        // return makes the function end\n        return;\n    }\n\n    // The header of the message indicates what type of message is\n    // Let's extract the header of the message\n    let header = message.substr(0, 5) // this line extracts the first 5 letters\n// =======================================\n// ========= Task: 3\n// =======================================\n// TODO: Check if the header of the message is \"order\"\n    if (header == \"order\") {\n        // The message is of type order!\n        // Just a visual representation\n        announceOrder();\n        // Decode the message to obtain the information\n        let messageInfo = decode(message);\n        //Process the order message information!\n        processOrderMessage(messageInfo)\n    }\n}\n\nfunction decode(message:string){\n    // The message received has four parts: order, Courier ID, ring bell, and delivery time.\n    // All the parts are together, separated by a :\n    // For example order:5:B:6\n    // We store the fields in variables starting with m (m for message)\n    let mType = \"\";\n    let mCourierId = 0;\n    let mDelyDoor = \"\";\n    let mDelyTime = 0;\n    let mParts = [];\n    // =======================================\n    // ========= Task: 4\n    // =======================================\n    //TODO: split the message by the separator :\n    //      take the message parts (0, 1, 2, and 3) in separated \n    //      variables (mType, mCourierId, mDelyDoor, mDelyTime)\n    // We need to split the parts by the separator\n    mParts = message.split(\":\")\n    mType = mParts[0];\n    mCourierId = parseInt(mParts[1]);\n    // mDelyDoor = mParts[2];\n    // mDelyTime = parseInt(mParts[3]);\n\n    // Return a structure with all the message information\n    return {\n        type: mType,\n        courierId: mCourierId,\n        delyDoor: mDelyDoor,\n        delyTime: mDelyTime\n    };\n}\n\nfunction processOrderMessage(messageInfo:any) {\n    // messageInfo has all the information of the message\n    // Use the information to decide what to do next\n\n    // Check if the order was sent to me :-O\n    if (messageInfo.CourierId == myID) {\n        // Caramba!! The order is for me!!!\n        // mark the flag order active!\n        orderActive = true\n        // save the message info into the micro:bit memory\n        delyDoor = messageInfo.DelyDoor\n        delyTime = messageInfo.DelyTime\n\n        // Show the door to deliver the order on the LED display\n        basic.showString(\"Door:\" + delyDoor)\n\n        // Start the countdown during \"delyTime\" seconds\n        countdown(delyTime)\n\n        // The countdown function ended.\n        // was the order delivered?  \n        // Check if you delivered the pizza (or not) \n        if (orderActive == true){\n            // The order remains pending. I am very sorry for you >:-D\n            deliveryFail() // booom!!!\n        }\n    } else { // This ELSE comes from above if (messageInfo.CourierId == myID)\n        // The order is not for me (fiuuuuu)\n        basic.pause(1000)\n        // Show I add a point\n        basic.showString(\"+1\")\n    }\n}\n\n// === Inputs handlers ===\n// This function executes when the button A is pressed\ninput.onButtonPressed(Button.A, function () {\n    // deliver the order to door \"A\"\n    deliverTo(\"A\"); // Use \"A\", not A\n})\n\n// This function executes when the button B is pressed\ninput.onButtonPressed(Button.B, function () {\n    // deliver the order to door \"B\".\n    deliverTo(\"B\"); // Use \"B\", not B\n})\n\n// This function executes when the pin 0 is closed\ninput.onPinPressed(TouchPin.P0, function () {\n    // deliver the order to door \"0\"\n    deliverTo(\"0\");\n})\n\n// This function executes when the pin 1 is closed\ninput.onPinPressed(TouchPin.P1, function () {\n    // deliver the order to door \"1\"\n    deliverTo(\"1\");\n})\n\n// This function executes when the pin 2 is closed\ninput.onPinPressed(TouchPin.P2, function () {\n    // deliver the order to door \"2\"\n    deliverTo(\"2\");\n})\n\n\n// === Helper: Handle Delivery Attempt ===\nfunction deliverTo(ringPressed: string) {\n    // Check if the game is over.\n    if (gameOver == true) \n    { // If the game is over, there is nothing to do\n        return // end of function\n    }\n\n    // NOTE: If you are reading this after the if gameOver validation, it means that\n    //       the game is not over. We keep delivering the order!\n    // The game is not over. Check if the order is active\n    if (orderActive == true) {\n        // The order is active! \n        // Check if delivered correctly. Door must equal ringbell\n        if (delyDoor == ringPressed){\n            // order delivered correctly. Well done!\n            deliveryOK()\n        } else {\n            // order is not delivered ok. I am very sorry for you :-p\n            deliveryFail()\n        }\n    }\n}\n\n// === Logo pressed: Create a pizza order ===\ninput.onLogoEvent(TouchButtonEvent.Pressed, createOrder)\n\nfunction createOrder() {\n    // Not create order if there is another order active already\n    if (orderActive == true) return;\n    // Not create order if the game is over already\n    if (gameOver == true) return;\n    const now = control.millis()\n    if (now - lastSendTime > cooldownTimer * 1000) {\n        lastSendTime = now\n// =======================================\n// ========= Task: 7\n// =======================================\n        let message = \"\"\n        // TODO: use encodeInfo funtion to create a message\n        // message = encodeInfo();\n        // TODO: use sendMessage function to send the message\n        // sendMessage(message);\n    } else {\n        basic.showIcon(IconNames.Chessboard)\n        basic.pause(200)\n    }\n}\n\n\n// === Helper: prepare Order ===\nfunction encodeInfo():string {\n// We need to prepare the order message before sending it.\n    // The message is comprised of several parts separated by a :\n    // Consider the following example\n    // - Type of message = order\n    // - courierID = 12\n    // - door = B\n    // - DelyTime = 5 seconds\n    // Combining all the data,\n    // you can CODIFY a message as order:12:B:5\n    \n// Let's start by creating our variables. The m in the name says is for messaging\n    let mType = \"order\"\n    let mCourierID;        // the courier destination\n    let mDoor;             // the door to deliver the order\n    let mDelyTime         // the time left to deliver the order\n    let mSeparator = \":\"  // a separator, to not mix the data\n    let message: string   // The message with the full order\n\n// Choose a courier to send the order\n    do { // Choose a random courier ID\n        mCourierID = randint(1, players)\n    } while (mCourierID == myID); // This checks that you don't send the order to yourself\n\n// Choose a random door\n    // We choose a random option from all the ringbellPanel chances\n    let ringbellOption = randint(0, ringbellPanel.length - 1)\n    // we use the option to choose from the ringbell panel\n    mDoor = ringbellPanel[ringbellOption]\n\n// Choose a delivery time\n    // Use the default delivery time\n    mDelyTime = defaultDelyTime\n\n// Show the targetID on screen (and play some sound)   \n    basic.showString(\"To:\" + mCourierID)\n    music.play(music.builtinPlayableSoundEffect(soundExpression.hello), music.PlaybackMode.InBackground)\n\n// Encode the information to create a message\n// =======================================\n// ========= Task: 5\n// =======================================\n    // TODO: concatenate the parts of information into a message.\n    //       Intercalate : in between as a separator\n    message = \"\" // concatenate + \":\" + the \":\" +  parts ;-)\n\n    // return the message\n    // The message order is ready! return the message\n    return message;\n}\n\nfunction sendMessage(message: string){\n    // send the message by radio!\n// =======================================\n// ========= Task: 6\n// =======================================\n    // TODO: use the radio.sendString function to send the message by radio\n    radio.sendString(\"\")\n}\n\n","README.md":"","backend.ts":"/****************************************************************************************\n * Project: Micro:bit Multiplayer Game\n * Description: Core logic and custom extensions for micro:bit multiplayer interaction.\n * \n * File: backend.ts\n * Contains: Helper functions to aliviate students' work\n * \n * Author: Sebastian Barillaro\n * Date: 2025-06-01\n * Platform: Microsoft MakeCode for micro:bit\n * \n * Notes:\n * - Designed for use with MakeCode editor (https://makecode.microbit.org/)\n * - Compatible with MakeCode's TypeScript (pxt) environment\n * \n * License: Reserved for Luxembourg Tech School ASBL\n ****************************************************************************************/\n\n\nlet lastSendTime = 0\nconst cooldownTimer = 10 //seconds\n\n// === Helper: Show current status (ID + Score) ===\nfunction showStatus() {\n    // Show ID and myScore on the LED display\n    basic.showString(\"ID:\" + myID + \" S:\" + myScore)\n}\nfunction startGame() {\n    // play starting sound\n    music.play(music.builtinPlayableSoundEffect(soundExpression.happy), music.PlaybackMode.InBackground)\n    // show the status!\n    showStatus()\n}\n\n// This function configures the device to end the game\nfunction endGame() {\n    // Set the flag gameOver \n    gameOver = true\n    // Deactivate any order\n    orderActive = false\n    //Stop the sound\n    music.stopAllSounds()\n    // Show the NO icon during 1 second (a visual reference)\n    basic.showIcon(IconNames.Ghost)\n    basic.pause(1000)\n    // show the final score on screen\n    showStatus()\n}\n\nfunction announceOrder(){\n    basic.showIcon(IconNames.Surprised)\n    \n    music._playDefaultBackground(music.builtInPlayableMelody(Melodies.BaDing), music.PlaybackMode.UntilDone)\n    // All players get a point for surviving this round\n    myScore++\n}\n\n\n\nfunction countdown(delyTime: number) {\n    for (let i = 0; i <= delyTime - 1; i++) {\n        music.playTone(262, 100)\n        // basic.showIcon(IconNames.Heart)\n        basic.showNumber(delyTime - i)\n        basic.pause(400)\n        music.playTone(349, 100)\n        basic.clearScreen()\n        basic.pause(400)\n        if (orderActive == false) {\n            break;\n        }\n    }\n}\n\n\n// === Helper: order delivered correctly ===\nfunction deliveryOK() {\n    orderActive = false\n    myScore += 5\n    music.stopAllSounds()\n    basic.showIcon(IconNames.Yes)\n    basic.pause(1000)\n    showStatus()\n}\n\n// === Helper: Delivery Fail ===\nfunction deliveryFail() {\n    orderActive = false\n    myScore = Math.max(0, myScore - 5)\n    music.stopAllSounds()\n    music.startMelody([\"C5\", \"B\", \"A\", \"G\", \"F\", \"E\", \"D\", \"C\"], MelodyOptions.Once)\n    basic.showIcon(IconNames.Skull)\n    basic.pause(1000)\n    showStatus()\n}\n\n","master.ts":"","pxt.json":"{\n    \"name\": \"fast-flourrious-T1\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\"\n    },\n    \"files\": [\n        \"main.ts\",\n        \"README.md\",\n        \"backend.ts\",\n        \"master.ts\"\n    ],\n    \"testFiles\": [\n        \"test.ts\"\n    ],\n    \"targetVersions\": {\n        \"target\": \"7.0.61\",\n        \"targetId\": \"microbit\"\n    },\n    \"supportedTargets\": [\n        \"microbit\"\n    ],\n    \"preferredEditor\": \"tsprj\",\n    \"languageRestriction\": \"javascript-only\"\n}\n","test.ts":"// tests go here; this will not be compiled when this package is used as an extension.\n"}},{"timestamp":1749803267288,"editorVersion":"7.0.61","text":{"main.ts":"/****************************************************************************************\n * Project: Micro:bit Multiplayer Game\n * Description: Core logic and custom extensions for micro:bit multiplayer interaction.\n * \n * File: main.ts\n * Contains: Main logic. Task 1\n * \n * Author: Sebastian Barillaro\n * Date: 2025-06-10\n * Platform: Microsoft MakeCode for micro:bit\n * \n * Notes:\n * - Designed for use with MakeCode editor (https://makecode.microbit.org/)\n * - Compatible with MakeCode's TypeScript (pxt) environment\n * \n * License: Reserved for Luxembourg Tech School ASBL\n ****************************************************************************************/\n\n\n// === Constants ===\nconst defaultDelyTime = 6  // seconds\nconst defaultRadioGroup = 10\nconst mGameOver = \"gameOver\"\n\n// === Flag Variables ===\nlet orderActive = false // false = order not active ; true = order activated!\nlet gameOver = false // false = game is NOT over (playing) ; true = the game is over.\n\n// === Support Variables ===\nlet delyDoor = \"\"\nlet delyTime = defaultDelyTime;\nlet myScore = 0\n\n// === Configuration variables ===\n// =======================================\n// ========= Task: \n// =======================================\n// TODO: Set printMessage to false to stop showing the message on the LED display\n// print radio Message\nlet printMessage = true;\n\n// Set the number of players!\nlet players = 20;\n// Set your ID (Must be unique in your group)\nlet myID = randint(1, players); // Change the random value for something fix\n// Set the difficulty of the game: \"easy\", (more to come later)\nlet difficulty = \"easy\";\n// Set the ringbell options list\nlet ringbellPanel = [\"A\", \"B\", \"0\", \"1\", \"2\"]\n\n\n// =======================================\n// ========= Task 1:\n// =======================================\n// Configure the radio Group\n// TODO: radio.setGroup(use the radioGroup here)\n// start the game!\n// TODO: Call the startGame function\n\n// === Receive Radio Message ===\n// This function executes when the device receives a radio message.\nradio.onReceivedString(radioMessageReceived)\n\n// === handler of the reception ===\nfunction radioMessageReceived(message: string) {\n    music.playTone(262, 100)\n\n    // You have received a radio message. We will print it on the display\n    if (printMessage == true){\n        basic.showString(message);\n    }\n\n    // If the game is over, we do nothing (return)\n    if (gameOver == true) {\n        // Show the NO icon during 1 second (a visual reference)\n        basic.showIcon(IconNames.Ghost)\n        basic.pause(1000)\n        return // This return instruction ends the function. \n               // It continues where it was called from\n    }\n\n    // The game is not over. Let's see what we have received\n// =======================================\n// ========= Task: 2\n// =======================================\n// TODO: check if the message received is equal to \"gameOver\"\n   if (false) {\n        // The message received indicates to end the game\n        endGame()\n        // return makes the function end\n        return;\n    }\n\n    // The header of the message indicates what type of message is\n    // Let's extract the header of the message\n    let header = message.substr(0, 5) // this line extracts the first 5 letters\n// =======================================\n// ========= Task: 3\n// =======================================\n// TODO: Check if the header of the message is \"order\"\n    if (false) {\n        // The message is of type order!\n        // Just a visual representation\n        announceOrder();\n        // Decode the message to obtain the information\n        let messageInfo = decode(message);\n        //Process the order message information!\n        processOrderMessage(messageInfo)\n    }\n}\n\nfunction decode(message:string){\n    // The message received has four parts: order, Courier ID, ring bell, and delivery time.\n    // All the parts are together, separated by a :\n    // For example order:5:B:6\n    // We store the fields in variables starting with m (m for message)\n    let mType = \"\";\n    let mCourierId = 0;\n    let mDelyDoor = \"\";\n    let mDelyTime = 0;\n    let mParts = [];\n    // =======================================\n    // ========= Task: 4\n    // =======================================\n    //TODO: split the message by the separator :\n    //      take the message parts (0, 1, 2, and 3) in separated \n    //      variables (mType, mCourierId, mDelyDoor, mDelyTime)\n    // We need to split the parts by the separator\n    mParts = message.split(\":\")\n    mType = mParts[0];\n    mCourierId = parseInt(mParts[1]);\n    // mDelyDoor = mParts[2];\n    // mDelyTime = parseInt(mParts[3]);\n\n    // Return a structure with all the message information\n    return {\n        type: mType,\n        courierId: mCourierId,\n        delyDoor: mDelyDoor,\n        delyTime: mDelyTime\n    };\n}\n\nfunction processOrderMessage(messageInfo:any) {\n    // messageInfo has all the information of the message\n    // Use the information to decide what to do next\n\n    // Check if the order was sent to me :-O\n    if (messageInfo.CourierId == myID) {\n        // Caramba!! The order is for me!!!\n        // mark the flag order active!\n        orderActive = true\n        // save the message info into the micro:bit memory\n        delyDoor = messageInfo.DelyDoor\n        delyTime = messageInfo.DelyTime\n\n        // Show the door to deliver the order on the LED display\n        basic.showString(\"Door:\" + delyDoor)\n\n        // Start the countdown during \"delyTime\" seconds\n        countdown(delyTime)\n\n        // The countdown function ended.\n        // was the order delivered?  \n        // Check if you delivered the pizza (or not) \n        if (orderActive == true){\n            // The order remains pending. I am very sorry for you >:-D\n            deliveryFail() // booom!!!\n        }\n    } else { // This ELSE comes from above if (messageInfo.CourierId == myID)\n        // The order is not for me (fiuuuuu)\n        basic.pause(1000)\n        // Show I add a point\n        basic.showString(\"+1\")\n    }\n}\n\n// === Inputs handlers ===\n// This function executes when the button A is pressed\ninput.onButtonPressed(Button.A, function () {\n    // deliver the order to door \"A\"\n    deliverTo(\"A\"); // Use \"A\", not A\n})\n\n// This function executes when the button B is pressed\ninput.onButtonPressed(Button.B, function () {\n    // deliver the order to door \"B\".\n    deliverTo(\"B\"); // Use \"B\", not B\n})\n\n// This function executes when the pin 0 is closed\ninput.onPinPressed(TouchPin.P0, function () {\n    // deliver the order to door \"0\"\n    deliverTo(\"0\");\n})\n\n// This function executes when the pin 1 is closed\ninput.onPinPressed(TouchPin.P1, function () {\n    // deliver the order to door \"1\"\n    deliverTo(\"1\");\n})\n\n// This function executes when the pin 2 is closed\ninput.onPinPressed(TouchPin.P2, function () {\n    // deliver the order to door \"2\"\n    deliverTo(\"2\");\n})\n\n\n// === Helper: Handle Delivery Attempt ===\nfunction deliverTo(ringPressed: string) {\n    // Check if the game is over.\n    if (gameOver == true) \n    { // If the game is over, there is nothing to do\n        return // end of function\n    }\n\n    // NOTE: If you are reading this after the if gameOver validation, it means that\n    //       the game is not over. We keep delivering the order!\n    // The game is not over. Check if the order is active\n    if (orderActive == true) {\n        // The order is active! \n        // Check if delivered correctly. Door must equal ringbell\n        if (delyDoor == ringPressed){\n            // order delivered correctly. Well done!\n            deliveryOK()\n        } else {\n            // order is not delivered ok. I am very sorry for you :-p\n            deliveryFail()\n        }\n    }\n}\n\n// === Logo pressed: Create a pizza order ===\ninput.onLogoEvent(TouchButtonEvent.Pressed, createOrder)\n\nfunction createOrder() {\n    // Not create order if there is another order active already\n    if (orderActive == true) return;\n    // Not create order if the game is over already\n    if (gameOver == true) return;\n    const now = control.millis()\n    if (now - lastSendTime > cooldownTimer * 1000) {\n        lastSendTime = now\n// =======================================\n// ========= Task: 7\n// =======================================\n        let message = \"\"\n        // TODO: use encodeInfo funtion to create a message\n        // message = encodeInfo();\n        // TODO: use sendMessage function to send the message\n        // sendMessage(message);\n    } else {\n        basic.showIcon(IconNames.Chessboard)\n        basic.pause(200)\n    }\n}\n\n\n// === Helper: prepare Order ===\nfunction encodeInfo():string {\n// We need to prepare the order message before sending it.\n    // The message is comprised of several parts separated by a :\n    // Consider the following example\n    // - Type of message = order\n    // - courierID = 12\n    // - door = B\n    // - DelyTime = 5 seconds\n    // Combining all the data,\n    // you can CODIFY a message as order:12:B:5\n    \n// Let's start by creating our variables. The m in the name says is for messaging\n    let mType = \"order\"\n    let mCourierID;        // the courier destination\n    let mDoor;             // the door to deliver the order\n    let mDelyTime         // the time left to deliver the order\n    let mSeparator = \":\"  // a separator, to not mix the data\n    let message: string   // The message with the full order\n\n// Choose a courier to send the order\n    do { // Choose a random courier ID\n        mCourierID = randint(1, players)\n    } while (mCourierID == myID); // This checks that you don't send the order to yourself\n\n// Choose a random door\n    // We choose a random option from all the ringbellPanel chances\n    let ringbellOption = randint(0, ringbellPanel.length - 1)\n    // we use the option to choose from the ringbell panel\n    mDoor = ringbellPanel[ringbellOption]\n\n// Choose a delivery time\n    // Use the default delivery time\n    mDelyTime = defaultDelyTime\n\n// Show the targetID on screen (and play some sound)   \n    basic.showString(\"To:\" + mCourierID)\n    music.play(music.builtinPlayableSoundEffect(soundExpression.hello), music.PlaybackMode.InBackground)\n\n// Encode the information to create a message\n// =======================================\n// ========= Task: 5\n// =======================================\n    // TODO: concatenate the parts of information into a message.\n    //       Intercalate : in between as a separator\n    message = \"\" // concatenate + \":\" + the \":\" +  parts ;-)\n\n    // return the message\n    // The message order is ready! return the message\n    return message;\n}\n\nfunction sendMessage(message: string){\n    // send the message by radio!\n    music.play(music.builtinPlayableSoundEffect(soundExpression.hello), music.PlaybackMode.UntilDone)\n// =======================================\n// ========= Task: 6\n// =======================================\n    // TODO: use the radio.sendString function to send the message by radio\n    radio.sendString(\"\")\n}\n\n","README.md":"","backend.ts":"/****************************************************************************************\n * Project: Micro:bit Multiplayer Game\n * Description: Core logic and custom extensions for micro:bit multiplayer interaction.\n * \n * File: backend.ts\n * Contains: Helper functions to aliviate students' work\n * \n * Author: Sebastian Barillaro\n * Date: 2025-06-01\n * Platform: Microsoft MakeCode for micro:bit\n * \n * Notes:\n * - Designed for use with MakeCode editor (https://makecode.microbit.org/)\n * - Compatible with MakeCode's TypeScript (pxt) environment\n * \n * License: Reserved for Luxembourg Tech School ASBL\n ****************************************************************************************/\n\n\nlet lastSendTime = 0\nconst cooldownTimer = 10 //seconds\n\n// === Helper: Show current status (ID + Score) ===\nfunction showStatus() {\n    // Show ID and myScore on the LED display\n    basic.showString(\"ID:\" + myID + \" S:\" + myScore)\n}\nfunction startGame() {\n    // play starting sound\n    music.play(music.builtinPlayableSoundEffect(soundExpression.happy), music.PlaybackMode.InBackground)\n    // show the status!\n    showStatus()\n}\n\n// This function configures the device to end the game\nfunction endGame() {\n    // Set the flag gameOver \n    gameOver = true\n    // Deactivate any order\n    orderActive = false\n    //Stop the sound\n    music.stopAllSounds()\n    // Show the NO icon during 1 second (a visual reference)\n    basic.showIcon(IconNames.Ghost)\n    basic.pause(1000)\n    // show the final score on screen\n    showStatus()\n}\n\nfunction announceOrder(){\n    basic.showIcon(IconNames.Surprised)\n    \n    music._playDefaultBackground(music.builtInPlayableMelody(Melodies.BaDing), music.PlaybackMode.UntilDone)\n    // All players get a point for surviving this round\n    myScore++\n}\n\n\n\nfunction countdown(delyTime: number) {\n    for (let i = 0; i <= delyTime - 1; i++) {\n        music.playTone(262, 100)\n        // basic.showIcon(IconNames.Heart)\n        basic.showNumber(delyTime - i)\n        basic.pause(400)\n        music.playTone(349, 100)\n        basic.clearScreen()\n        basic.pause(400)\n        if (orderActive == false) {\n            break;\n        }\n    }\n}\n\n\n// === Helper: order delivered correctly ===\nfunction deliveryOK() {\n    orderActive = false\n    myScore += 5\n    music.stopAllSounds()\n    basic.showIcon(IconNames.Yes)\n    basic.pause(1000)\n    showStatus()\n}\n\n// === Helper: Delivery Fail ===\nfunction deliveryFail() {\n    orderActive = false\n    myScore = Math.max(0, myScore - 5)\n    music.stopAllSounds()\n    music.startMelody([\"C5\", \"B\", \"A\", \"G\", \"F\", \"E\", \"D\", \"C\"], MelodyOptions.Once)\n    basic.showIcon(IconNames.Skull)\n    basic.pause(1000)\n    showStatus()\n}\n\n","master.ts":"","pxt.json":"{\n    \"name\": \"fast-flourrious-T1\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\"\n    },\n    \"files\": [\n        \"main.ts\",\n        \"README.md\",\n        \"backend.ts\",\n        \"master.ts\"\n    ],\n    \"testFiles\": [\n        \"test.ts\"\n    ],\n    \"targetVersions\": {\n        \"target\": \"7.0.61\",\n        \"targetId\": \"microbit\"\n    },\n    \"supportedTargets\": [\n        \"microbit\"\n    ],\n    \"preferredEditor\": \"tsprj\",\n    \"languageRestriction\": \"javascript-only\"\n}\n","test.ts":"// tests go here; this will not be compiled when this package is used as an extension.\n"}}],"shares":[],"lastSaveTime":1749803267302}